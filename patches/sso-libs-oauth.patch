diff --git a/api/libs/oauth.py b/api/libs/oauth.py
index 889a5a3..5555c4f 100644
--- a/api/libs/oauth.py
+++ b/api/libs/oauth.py
@@ -2,6 +2,10 @@ import urllib.parse
 from dataclasses import dataclass
 
 import httpx
+import hashlib
+import base64
+import secrets
+import json
 
 
 @dataclass
@@ -130,3 +134,80 @@ class GoogleOAuth(OAuth):
 
     def _transform_user_info(self, raw_info: dict) -> OAuthUserInfo:
         return OAuthUserInfo(id=str(raw_info["sub"]), name="", email=raw_info["email"])
+
+
+class KeycloakOAuth(OAuth):
+    """
+    Minimal OAuth2/OIDC client for Keycloak with PKCE support.
+
+    issuer_url should be like: http://localhost:8080/realms/dify
+    which yields standard endpoints under:
+      - {issuer_url}/protocol/openid-connect/auth
+      - {issuer_url}/protocol/openid-connect/token
+      - {issuer_url}/protocol/openid-connect/userinfo
+    """
+
+    def __init__(self, client_id: str, client_secret: str, redirect_uri: str, issuer_url: str):
+        super().__init__(client_id, client_secret, redirect_uri)
+        self.issuer_url = issuer_url.rstrip("/")
+        self._AUTH_URL = f"{self.issuer_url}/protocol/openid-connect/auth"
+        self._TOKEN_URL = f"{self.issuer_url}/protocol/openid-connect/token"
+        self._USER_INFO_URL = f"{self.issuer_url}/protocol/openid-connect/userinfo"
+
+        # Generate PKCE parameters
+        self.code_verifier = base64.urlsafe_b64encode(secrets.token_bytes(32)).decode('utf-8').rstrip('=')
+        self.code_challenge = base64.urlsafe_b64encode(
+            hashlib.sha256(self.code_verifier.encode('utf-8')).digest()
+        ).decode('utf-8').rstrip('=')
+
+    def get_authorization_url(self, invite_token: str = None):
+        params = {
+            "client_id": self.client_id,
+            "response_type": "code",
+            "redirect_uri": self.redirect_uri,
+            # request minimal scopes to retrieve email
+            "scope": "openid email profile",
+            # PKCE parameters
+            "code_challenge": self.code_challenge,
+            "code_challenge_method": "S256",
+        }
+        # Encode code_verifier in state to persist it across the OAuth flow
+        state_data = {"code_verifier": self.code_verifier}
+        if invite_token:
+            state_data["invite_token"] = invite_token
+        params["state"] = base64.urlsafe_b64encode(json.dumps(state_data).encode()).decode()
+        return f"{self._AUTH_URL}?{urllib.parse.urlencode(params)}"
+
+    def set_code_verifier(self, code_verifier: str):
+        """Set the code verifier from state parameter during callback"""
+        self.code_verifier = code_verifier
+
+    def get_access_token(self, code: str):
+        data = {
+            "client_id": self.client_id,
+            "client_secret": self.client_secret,
+            "code": code,
+            "grant_type": "authorization_code",
+            "redirect_uri": self.redirect_uri,
+            "code_verifier": self.code_verifier,
+        }
+        headers = {"Accept": "application/json"}
+        response = requests.post(self._TOKEN_URL, data=data, headers=headers, verify=False)
+        response.raise_for_status()
+        response_json = response.json()
+        access_token = response_json.get("access_token")
+        if not access_token:
+            raise ValueError(f"Error in Keycloak OAuth: {response_json}")
+        return access_token
+
+    def get_raw_user_info(self, token: str):
+        headers = {"Authorization": f"Bearer {token}"}
+        response = requests.get(self._USER_INFO_URL, headers=headers, verify=False)
+        response.raise_for_status()
+        return response.json()
+
+    def _transform_user_info(self, raw_info: dict) -> OAuthUserInfo:
+        # Keycloak OIDC userinfo contains 'sub' and may include 'email' and 'name'
+        email = raw_info.get("email") or ""
+        name = raw_info.get("name") or raw_info.get("preferred_username") or ""
+        return OAuthUserInfo(id=str(raw_info.get("sub", "")), name=name, email=email)
