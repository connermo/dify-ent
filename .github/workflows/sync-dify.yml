name: Sync Dify from Upstream and Build Images

on:
  workflow_dispatch:
    # 允许手动触发
    inputs:
      force_sync:
        description: 'Force sync even if no updates'
        required: false
        default: false
        type: boolean
      full_multiarch:
        description: 'Build multi-arch images (linux/amd64, linux/arm64). If false, only build linux/amd64 for speed.'
        required: false
        default: false
        type: boolean
  push:
    branches:
      - main
    paths:
      - '.github/workflows/sync-dify.yml'
      - 'dify/api/**'
      - 'dify/web/**'
      - 'dify/docker/docker-compose.yaml'
      - '*.patch'
      - 'patches/**'
      - 'scripts/**'
      - 'LAST_UPSTREAM_RELEASE'
      - 'trigger-build.txt'

env:
  UPSTREAM_REPO: langgenius/dify
  UPSTREAM_BRANCH: main
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/dify
  DOCKER_PLATFORMS: linux/amd64,linux/arm64
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME || github.repository_owner }}

jobs:
  sync-and-build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
      id-token: write
    concurrency:
      group: build-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Set build platforms
        run: |
          if [ "${{ github.event.inputs.full_multiarch }}" = "true" ]; then
            echo "BUILD_PLATFORMS=linux/amd64,linux/arm64" >> $GITHUB_ENV
          else
            echo "BUILD_PLATFORMS=linux/amd64" >> $GITHUB_ENV
          fi
      - name: Checkout current repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get latest upstream release tag (digits only)
        id: latest-release
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // Get all releases (paginated)
              const releases = await github.paginate(github.rest.repos.listReleases, {
                owner: 'langgenius',
                repo: 'dify',
                per_page: 100
              });
              
              console.log(`Found ${releases.length} total releases`);
              
              // Filter releases that start with digits (not 'v')
              const numericReleases = releases.filter(release => {
                const tagName = release.tag_name;
                return /^\d/.test(tagName) && !release.prerelease && !release.draft;
              });
              
              console.log(`Found ${numericReleases.length} numeric releases (non-prerelease)`);
              
              if (numericReleases.length === 0) {
                core.setFailed('No numeric releases found');
                return;
              }
              
              // Sort by creation date (newest first) and get the latest
              numericReleases.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              const latestRelease = numericReleases[0];
              
              console.log(`Latest numeric release: ${latestRelease.tag_name}`);
              console.log(`Release date: ${latestRelease.created_at}`);
              
              core.setOutput('tag', latestRelease.tag_name);
              core.setOutput('tarball_url', latestRelease.tarball_url);
              
              // Log first 5 numeric releases for debugging
              console.log('Recent numeric releases:');
              numericReleases.slice(0, 5).forEach((rel, idx) => {
                console.log(`  ${idx + 1}. ${rel.tag_name} (${rel.created_at})`);
              });
              
            } catch (error) {
              core.setFailed(`Failed to get releases: ${error.message}`);
            }

      - name: Export release tag to env
        run: |
          echo "UPSTREAM_RELEASE_TAG=${{ steps.latest-release.outputs.tag }}" >> $GITHUB_ENV

      - name: Check for updates (latest release)
        id: check-updates
        run: |
          echo "Latest upstream release: $UPSTREAM_RELEASE_TAG"
          if [ -f LAST_UPSTREAM_RELEASE ]; then
            PREV_TAG=$(cat LAST_UPSTREAM_RELEASE)
          else
            PREV_TAG=""
          fi
          
          # Check if there are patch file changes in recent commits (last 5 commits)
          PATCH_CHANGES=$(git diff HEAD~5 --name-only | grep '\.patch$' || echo "")
          WORKFLOW_CHANGES=$(git diff HEAD~5 --name-only | grep '.github/workflows/sync-dify.yml' || echo "")
          SCRIPT_CHANGES=$(git diff HEAD~5 --name-only | grep '^scripts/' || echo "")
          
          # Check for any new patch files that were added
          NEW_PATCHES=$(git diff --cached --name-only | grep '\.patch$' || git ls-files patches/*.patch 2>/dev/null | grep -v "^\.git" || echo "")
          
          echo "Previous tag: $PREV_TAG"
          echo "Current tag: $UPSTREAM_RELEASE_TAG"
          echo "Force sync: ${{ github.event.inputs.force_sync }}"
          echo "Patch changes: $PATCH_CHANGES"
          echo "Workflow changes: $WORKFLOW_CHANGES"
          echo "Script changes: $SCRIPT_CHANGES"
          
          # Always build if:
          # 1. Force sync is enabled
          # 2. Version changed
          # 3. There are patch/script/workflow changes
          # 4. LAST_UPSTREAM_RELEASE file doesn't exist (first run)
          if [ "${{ github.event.inputs.force_sync }}" = "true" ]; then
            echo "updates=true" >> $GITHUB_OUTPUT
            echo "Force sync enabled - will build images"
          elif [ "$PREV_TAG" != "$UPSTREAM_RELEASE_TAG" ]; then
            echo "updates=true" >> $GITHUB_OUTPUT
            echo "Version changed from '$PREV_TAG' to '$UPSTREAM_RELEASE_TAG' - will build images"
          elif [ -z "$PREV_TAG" ]; then
            echo "updates=true" >> $GITHUB_OUTPUT
            echo "First run (no LAST_UPSTREAM_RELEASE) - will build images"
          elif [ -n "$PATCH_CHANGES" ] || [ -n "$WORKFLOW_CHANGES" ] || [ -n "$SCRIPT_CHANGES" ]; then
            echo "updates=true" >> $GITHUB_OUTPUT
            if [ -n "$PATCH_CHANGES" ]; then
              echo "Patch file changes detected: $PATCH_CHANGES - will rebuild images"
            fi
            if [ -n "$WORKFLOW_CHANGES" ]; then
              echo "Workflow changes detected - will rebuild images"
            fi
            if [ -n "$SCRIPT_CHANGES" ]; then
              echo "Script changes detected: $SCRIPT_CHANGES - will rebuild images"
            fi
          else
            echo "updates=false" >> $GITHUB_OUTPUT
            echo "Already at latest upstream release $UPSTREAM_RELEASE_TAG and no changes detected"
          fi

      - name: Prepare workspace
        if: steps.check-updates.outputs.updates == 'true'
        run: |
          # 备份现有的SSO集成修改
          mkdir -p /tmp/backup
          cp -r dify/api/libs/oauth.py /tmp/backup/ 2>/dev/null || true
          cp -r dify/api/configs/feature/__init__.py /tmp/backup/ 2>/dev/null || true
          cp -r dify/api/controllers/console/auth/oauth.py /tmp/backup/ 2>/dev/null || true
          cp -r dify/docker/docker-compose.yaml /tmp/backup/ 2>/dev/null || true
          cp -r keycloak/ /tmp/backup/ 2>/dev/null || true

      - name: Download and extract latest release
        if: steps.check-updates.outputs.updates == 'true'
        run: |
          echo "Downloading Dify release ${{ env.UPSTREAM_RELEASE_TAG }}"
          
          # Create temporary directory for download
          mkdir -p /tmp/dify-download
          cd /tmp/dify-download
          
          # Download release tarball
          curl -L -o dify-release.tar.gz "${{ steps.latest-release.outputs.tarball_url }}"
          
          # Extract tarball
          tar -xzf dify-release.tar.gz --strip-components=1
          
          # Backup existing dify directory
          cd ${{ github.workspace }}
          if [ -d "dify" ]; then
            rm -rf dify.backup 2>/dev/null || true
            mv dify dify.backup
          fi
          
          # Move extracted files to dify directory
          mv /tmp/dify-download dify
          
          echo "UPSTREAM_SRC=dify" >> $GITHUB_ENV

      - name: Ensure dify directory exists (for patch-only updates)
        if: steps.check-updates.outputs.updates == 'true'
        run: |
          # If we don't have dify directory but need to apply patches, download current release
          if [ ! -d "dify" ]; then
            echo "No dify directory found, downloading current release ${{ env.UPSTREAM_RELEASE_TAG }}"
            
            # Create temporary directory for download
            mkdir -p /tmp/dify-download
            cd /tmp/dify-download
            
            # Download release tarball
            curl -L -o dify-release.tar.gz "${{ steps.latest-release.outputs.tarball_url }}"
            
            # Extract tarball
            tar -xzf dify-release.tar.gz --strip-components=1
            
            # Move extracted files to dify directory
            cd ${{ github.workspace }}
            mv /tmp/dify-download dify
          fi
          
          # Always set this for consistency
          echo "UPSTREAM_SRC=dify" >> $GITHUB_ENV

      - name: Calculate SSO patches hash
        if: steps.check-updates.outputs.updates == 'true'
        id: patches-hash
        run: |
          # Calculate hash of all SSO patch files to bust Docker cache when patches change
          PATCHES_HASH=$(cat patches/sso-*.patch | sha256sum | cut -d' ' -f1)
          echo "patches_hash=${PATCHES_HASH}" >> $GITHUB_OUTPUT
          echo "📋 SSO Patches Hash: ${PATCHES_HASH}"

          # Check if patches hash changed from last build
          LAST_HASH=""
          if [ -f ".sso-patches-hash" ]; then
            LAST_HASH=$(cat .sso-patches-hash)
          fi

          if [ "$LAST_HASH" != "$PATCHES_HASH" ]; then
            echo "patches_changed=true" >> $GITHUB_OUTPUT
            echo "🔄 SSO patches changed (old: ${LAST_HASH:-none}, new: ${PATCHES_HASH})"
          else
            echo "patches_changed=false" >> $GITHUB_OUTPUT
            echo "✅ SSO patches unchanged"
          fi

          # Save current hash for next build
          echo "${PATCHES_HASH}" > .sso-patches-hash

      - name: Apply SSO integration patches
        if: steps.check-updates.outputs.updates == 'true'
        run: |
          echo "🚀 Applying SSO integration patches..."
          echo "Current directory: $(pwd)"
          echo "Checking dify directory structure:"
          ls -la dify/ | head -10
          echo ""

          cd dify

          # Initialize git repository for applying patches
          if [ ! -d ".git" ]; then
            echo "📝 Initializing git repository..."
            git init
            git add .
            git commit -m "Initial commit from upstream ${{ env.UPSTREAM_RELEASE_TAG }}"
          fi

          # Apply all SSO patches in order
          echo "📦 Applying SSO patches from patches/ directory..."

          # Backend patches
          for patch_file in sso-config-feature sso-libs-oauth sso-controller-oauth; do
            if [ -f "../patches/${patch_file}.patch" ]; then
              echo "  → Applying ${patch_file}.patch..."
              if ! git apply "../patches/${patch_file}.patch"; then
                echo "❌ Error: Failed to apply ${patch_file}.patch"
                exit 1
              fi
            else
              echo "⚠️  Warning: ${patch_file}.patch not found"
            fi
          done

          # Frontend patches
          for patch_file in sso-web-social-auth sso-web-normal-form; do
            if [ -f "../patches/${patch_file}.patch" ]; then
              echo "  → Applying ${patch_file}.patch..."
              if ! git apply "../patches/${patch_file}.patch"; then
                echo "❌ Error: Failed to apply ${patch_file}.patch"
                exit 1
              fi
            else
              echo "⚠️  Warning: ${patch_file}.patch not found"
            fi
          done

          # Docker configuration patch
          if [ -f "../patches/sso-docker-compose.patch" ]; then
            echo "  → Applying sso-docker-compose.patch..."
            if ! git apply "../patches/sso-docker-compose.patch"; then
              echo "❌ Error: Failed to apply sso-docker-compose.patch"
              exit 1
            fi
          fi

          cd ..

          echo ""
          echo "🔍 Verifying SSO patches were applied..."

          # Verify Keycloak config
          if ! grep -q "KEYCLOAK_CLIENT_ID" dify/api/configs/feature/__init__.py; then
            echo "❌ Error: Keycloak config not found in feature/__init__.py"
            echo "File content (last 20 lines):"
            tail -20 dify/api/configs/feature/__init__.py
            exit 1
          fi
          echo "✅ Keycloak config found in feature/__init__.py"

          # Verify frontend SSO icon
          if ! grep -q "RiUserLine" dify/web/app/signin/components/social-auth.tsx; then
            echo "❌ Error: RiUserLine import not found in social-auth.tsx"
            echo "File content (first 10 lines):"
            head -10 dify/web/app/signin/components/social-auth.tsx
            exit 1
          fi
          echo "✅ RiUserLine import found in social-auth.tsx"

          # Verify OAuth providers API
          if ! grep -q "OAuthProvidersApi" dify/api/controllers/console/auth/oauth.py; then
            echo "❌ Error: OAuthProvidersApi not found in oauth.py"
            echo "File content (last 30 lines):"
            tail -30 dify/api/controllers/console/auth/oauth.py
            exit 1
          fi
          echo "✅ OAuthProvidersApi found in oauth.py"

          # Verify KeycloakOAuth class
          if ! grep -q "KeycloakOAuth" dify/api/libs/oauth.py; then
            echo "❌ Error: KeycloakOAuth class not found in libs/oauth.py"
            exit 1
          fi
          echo "✅ KeycloakOAuth class found in libs/oauth.py"

          echo ""
          echo "✅ All SSO patches verified successfully!"
          echo "📋 Summary:"
          echo "  - Keycloak configuration: ✅"
          echo "  - Frontend SSO button: ✅"
          echo "  - OAuth providers API: ✅"
          echo "  - KeycloakOAuth class: ✅"

          # Create marker files with patch hash to bust Docker cache
          echo "${{ steps.patches-hash.outputs.patches_hash }}" > dify/api/.sso-patches-version
          echo "${{ steps.patches-hash.outputs.patches_hash }}" > dify/web/.sso-patches-version
          echo "📝 Created cache busting marker files with hash: ${{ steps.patches-hash.outputs.patches_hash }}"

      - name: Setup Docker Buildx
        if: steps.check-updates.outputs.updates == 'true'
        uses: docker/setup-buildx-action@v3
        with:
          platforms: ${{ env.BUILD_PLATFORMS }}

      - name: Login to GitHub Container Registry
        if: steps.check-updates.outputs.updates == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Login to Docker Hub
        if: steps.check-updates.outputs.updates == 'true'
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push API image
        if: steps.check-updates.outputs.updates == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.UPSTREAM_SRC }}/api
          platforms: ${{ env.BUILD_PLATFORMS }}
          push: true
          no-cache: ${{ steps.patches-hash.outputs.patches_changed == 'true' }}
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-api:${{ env.UPSTREAM_RELEASE_TAG }}
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-api:latest
            ${{ env.DOCKERHUB_USERNAME }}/dify-api:${{ env.UPSTREAM_RELEASE_TAG }}
            ${{ env.DOCKERHUB_USERNAME }}/dify-api:latest
          provenance: false
          cache-from: |
            type=gha
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-api:${{ env.UPSTREAM_RELEASE_TAG }}
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-api:latest
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-api:cache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            SSO_PATCHES_HASH=${{ steps.patches-hash.outputs.patches_hash }}

      - name: Build and push Web image
        if: steps.check-updates.outputs.updates == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.UPSTREAM_SRC }}/web
          platforms: ${{ env.BUILD_PLATFORMS }}
          push: true
          no-cache: ${{ steps.patches-hash.outputs.patches_changed == 'true' }}
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-web:${{ env.UPSTREAM_RELEASE_TAG }}
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-web:latest
            ${{ env.DOCKERHUB_USERNAME }}/dify-web:${{ env.UPSTREAM_RELEASE_TAG }}
            ${{ env.DOCKERHUB_USERNAME }}/dify-web:latest
          provenance: false
          cache-from: |
            type=gha
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-web:${{ env.UPSTREAM_RELEASE_TAG }}
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-web:latest
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-web:cache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            SSO_PATCHES_HASH=${{ steps.patches-hash.outputs.patches_hash }}

      - name: Build and push Worker image
        if: steps.check-updates.outputs.updates == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.UPSTREAM_SRC }}/api
          platforms: ${{ env.BUILD_PLATFORMS }}
          push: true
          no-cache: ${{ steps.patches-hash.outputs.patches_changed == 'true' }}
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-worker:${{ env.UPSTREAM_RELEASE_TAG }}
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-worker:latest
            ${{ env.DOCKERHUB_USERNAME }}/dify-worker:${{ env.UPSTREAM_RELEASE_TAG }}
            ${{ env.DOCKERHUB_USERNAME }}/dify-worker:latest
          provenance: false
          cache-from: |
            type=gha
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-worker:${{ env.UPSTREAM_RELEASE_TAG }}
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-worker:latest
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-worker:cache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            SERVICE_TYPE=worker
            SSO_PATCHES_HASH=${{ steps.patches-hash.outputs.patches_hash }}

      - name: Make packages public
        if: steps.check-updates.outputs.updates == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Setting package visibility to public..."
          
          # Function to make a package public
          make_package_public() {
            local package_name=$1
            echo "Making package $package_name public..."
            
            # Use GitHub CLI to make package public
            gh api \
              --method PATCH \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/user/packages/container/$package_name" \
              -f visibility=public || echo "Failed to make $package_name public (might already be public)"
          }
          
          # Make all packages public
          # Make GitHub Container Registry packages public
          make_package_public "dify-api"
          make_package_public "dify-web" 
          make_package_public "dify-worker"
          
          echo "✅ GitHub Container Registry packages set to public"
          echo "✅ Docker Hub images pushed to ${{ env.DOCKERHUB_USERNAME }}/dify-{api,web,worker}"
          
          echo "✅ Package visibility updated"

      - name: Commit and push changes
        if: steps.check-updates.outputs.updates == 'true'
        run: |
          # Record the upstream release tag
          echo "${{ env.UPSTREAM_RELEASE_TAG }}" > LAST_UPSTREAM_RELEASE

          # Add SSO patches hash file for tracking
          git add .sso-patches-hash

          git add .
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "🚀 Sync from upstream ${{ env.UPSTREAM_RELEASE_TAG }}
            
            - ✅ Updated dify/ to release ${{ env.UPSTREAM_RELEASE_TAG }}
            - ✅ Applied Keycloak OAuth integration (SSO) automatically
            - ✅ Added OAuth providers API endpoint
            - ✅ Updated frontend with SSO login button (RiUserLine icon)
            - ✅ Updated docker-compose.yaml with SSO environment variables
            - ✅ Built and pushed Docker images with latest upstream changes
            
            🔗 Upstream: ${{ env.UPSTREAM_REPO }}@${{ env.UPSTREAM_RELEASE_TAG }}
            📦 Images: 
              - ghcr.io/${{ github.repository_owner }}/dify-{api,web,worker}:${{ env.UPSTREAM_RELEASE_TAG }}
              - docker.io/${{ env.DOCKERHUB_USERNAME }}/dify-{api,web,worker}:${{ env.UPSTREAM_RELEASE_TAG }}"
            git push origin main
          fi

      - name: Create or Update Release
        if: steps.check-updates.outputs.updates == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if release already exists
          if gh release view "${{ env.UPSTREAM_RELEASE_TAG }}" >/dev/null 2>&1; then
            echo "Release ${{ env.UPSTREAM_RELEASE_TAG }} already exists, updating it..."
            gh release edit "${{ env.UPSTREAM_RELEASE_TAG }}" \
              --title "Dify Enterprise SSO - ${{ env.UPSTREAM_RELEASE_TAG }} (Updated $(date +'%Y-%m-%d %H:%M'))" \
              --notes "## 🚀 Dify Enterprise SSO Release (Updated)
              
              This release includes:
              - Latest Dify updates from upstream repository
              - Keycloak OAuth integration patch applied
              - **Disable conversation logging patch applied** 🔒
              - Updated docker-compose.yaml with Keycloak environment variables
              - Fresh Docker images built from latest upstream code
              
              ### 🔗 Docker Images (Updated)
              
              #### GitHub Container Registry
              - **API**: \`ghcr.io/${{ github.repository_owner }}/dify-api:latest\`
              - **Web**: \`ghcr.io/${{ github.repository_owner }}/dify-web:latest\`
              - **Worker**: \`ghcr.io/${{ github.repository_owner }}/dify-worker:latest\`
              
              #### Docker Hub
              - **API**: \`docker.io/${{ env.DOCKERHUB_USERNAME }}/dify-api:latest\`
              - **Web**: \`docker.io/${{ env.DOCKERHUB_USERNAME }}/dify-web:latest\`
              - **Worker**: \`docker.io/${{ env.DOCKERHUB_USERNAME }}/dify-worker:latest\`
              
              ### 📋 Latest Changes
              
              - ✅ SSO integration with Keycloak OAuth2/OIDC
              - ✅ Dynamic OAuth providers API
              - ✅ User-friendly SSO login button with icon
              - ✅ PKCE security support
              - ✅ Synced from upstream: langgenius/dify@main
              
              Last updated: $(date +'%Y-%m-%d %H:%M UTC')"
          else
            echo "Creating new release ${{ env.UPSTREAM_RELEASE_TAG }}..."
            gh release create "${{ env.UPSTREAM_RELEASE_TAG }}" \
              --title "Dify Enterprise SSO - ${{ env.UPSTREAM_RELEASE_TAG }}" \
              --notes "## 🚀 Dify Enterprise SSO Release
              
              This release includes:
              - Latest Dify updates from upstream repository
              - ✅ Keycloak OAuth2/OIDC SSO integration
              - ✅ OAuth providers API endpoint
              - ✅ SSO login button with user icon (RiUserLine)
              - ✅ PKCE (Proof Key for Code Exchange) support
              - ✅ Updated docker-compose.yaml with SSO environment variables
              - ✅ Fresh Docker images built from latest upstream code
              
              ### 🔗 Docker Images
              
              #### GitHub Container Registry
              - **API**: \`ghcr.io/${{ github.repository_owner }}/dify-api:latest\`
              - **Web**: \`ghcr.io/${{ github.repository_owner }}/dify-web:latest\`
              - **Worker**: \`ghcr.io/${{ github.repository_owner }}/dify-worker:latest\`
              
              #### Docker Hub
              - **API**: \`docker.io/${{ env.DOCKERHUB_USERNAME }}/dify-api:latest\`
              - **Web**: \`docker.io/${{ env.DOCKERHUB_USERNAME }}/dify-web:latest\`
              - **Worker**: \`docker.io/${{ env.DOCKERHUB_USERNAME }}/dify-worker:latest\`
              
              ### 📋 Features
              
              - ✅ Keycloak OAuth2/OIDC SSO integration
              - ✅ Dynamic OAuth providers API
              - ✅ User-friendly SSO login button with icon
              - ✅ PKCE security support"
          fi

      - name: Update README with latest info
        if: steps.check-updates.outputs.updates == 'true'
        run: |
          # 更新README中的版本信息
          if grep -q "Last Updated:" README.md; then
            sed -i "s/Last Updated:.*/Last Updated: $(date +'%Y-%m-%d %H:%M UTC')/" README.md
          else
            echo "" >> README.md
            echo "## 📅 Version Information" >> README.md
            echo "" >> README.md
            echo "**Last Updated**: $(date +'%Y-%m-%d %H:%M UTC')" >> README.md
          fi
          
          if grep -q "Upstream Version:" README.md; then
            sed -i "s/Upstream Version:.*/Upstream Version: $(git rev-parse upstream\/${{ env.UPSTREAM_BRANCH }})/" README.md
          else
            echo "**Upstream Version**: $(git rev-parse upstream/${{ env.UPSTREAM_BRANCH }})" >> README.md
          fi
          
          git add README.md
          if git diff --staged --quiet; then
            echo "No README changes to commit"
          else
            git commit -m "Update README with latest sync information"
            git push origin main
          fi

      - name: Comment on PR if exists
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## 🔄 Dify Sync Status
            
              **Status**: ${{ steps.check-updates.outputs.updates == 'true' && '✅ Updated from upstream' || '✅ Already up to date' }}
              
              **Last Check**: $(date -u +'%Y-%m-%d %H:%M UTC')
              
              **Upstream Repository**: ${{ env.UPSTREAM_REPO }}
              **Upstream Branch**: ${{ env.UPSTREAM_BRANCH }}
              
              ${{ steps.check-updates.outputs.updates == 'true' && '**Changes Applied**:\n- ✅ Keycloak OAuth patch applied\n- ✅ Docker images built and pushed\n- ✅ docker-compose.yaml updated\n- ✅ Release created' || '**No Updates**: Repository is already synchronized with upstream' }}`
            })

      - name: Summary
        run: |
          echo "## 🎯 Sync Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Repository**: ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "**Upstream**: ${{ env.UPSTREAM_REPO }}@${{ env.UPSTREAM_BRANCH }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status**: ${{ steps.check-updates.outputs.updates == 'true' && '🔄 Updated' || '✅ Up to date' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check-updates.outputs.updates }}" = "true" ]; then
            echo "### 📦 Docker Images Built" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "#### GitHub Container Registry" >> $GITHUB_STEP_SUMMARY
            echo "- **API**: \`${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-api:latest\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Web**: \`${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-web:latest\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Worker**: \`${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-worker:latest\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "#### Docker Hub" >> $GITHUB_STEP_SUMMARY
            echo "- **API**: \`docker.io/${{ env.DOCKERHUB_USERNAME }}/dify-api:latest\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Web**: \`docker.io/${{ env.DOCKERHUB_USERNAME }}/dify-web:latest\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Worker**: \`docker.io/${{ env.DOCKERHUB_USERNAME }}/dify-worker:latest\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### 🔧 Changes Applied" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Keycloak OAuth2/OIDC SSO integration" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ OAuth providers API endpoint" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ SSO login button with user icon" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ PKCE security support" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Environment variables updated" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Docker images rebuilt" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Release created" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### 🌐 Multi-Platform Support" >> $GITHUB_STEP_SUMMARY
            echo "Images built for: \`${{ env.DOCKER_PLATFORMS }}\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ℹ️ No Updates Required" >> $GITHUB_STEP_SUMMARY
            echo "Repository is already synchronized with upstream." >> $GITHUB_STEP_SUMMARY
          fi
