name: Sync Dify from Upstream and Build Images

on:
  workflow_dispatch:
    # 允许手动触发
    inputs:
      force_sync:
        description: 'Force sync even if no updates'
        required: false
        default: false
        type: boolean
      full_multiarch:
        description: 'Build multi-arch images (linux/amd64, linux/arm64). If false, only build linux/amd64 for speed.'
        required: false
        default: false
        type: boolean
  push:
    branches:
      - main
    paths:
      - '.github/workflows/sync-dify.yml'
      - 'dify/api/**'
      - 'dify/docker/docker-compose.yaml'

env:
  UPSTREAM_REPO: langgenius/dify
  UPSTREAM_BRANCH: main
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/dify
  DOCKER_PLATFORMS: linux/amd64,linux/arm64

jobs:
  sync-and-build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
      id-token: write
    concurrency:
      group: build-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Set build platforms
        run: |
          if [ "${{ github.event.inputs.full_multiarch }}" = "true" ]; then
            echo "BUILD_PLATFORMS=linux/amd64,linux/arm64" >> $GITHUB_ENV
          else
            echo "BUILD_PLATFORMS=linux/amd64" >> $GITHUB_ENV
          fi
      - name: Checkout current repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get latest upstream release tag (digits only)
        id: latest-release
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // Get all releases (paginated)
              const releases = await github.paginate(github.rest.repos.listReleases, {
                owner: 'langgenius',
                repo: 'dify',
                per_page: 100
              });
              
              console.log(`Found ${releases.length} total releases`);
              
              // Filter releases that start with digits (not 'v')
              const numericReleases = releases.filter(release => {
                const tagName = release.tag_name;
                return /^\d/.test(tagName) && !release.prerelease && !release.draft;
              });
              
              console.log(`Found ${numericReleases.length} numeric releases (non-prerelease)`);
              
              if (numericReleases.length === 0) {
                core.setFailed('No numeric releases found');
                return;
              }
              
              // Sort by creation date (newest first) and get the latest
              numericReleases.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              const latestRelease = numericReleases[0];
              
              console.log(`Latest numeric release: ${latestRelease.tag_name}`);
              console.log(`Release date: ${latestRelease.created_at}`);
              
              core.setOutput('tag', latestRelease.tag_name);
              core.setOutput('tarball_url', latestRelease.tarball_url);
              
              // Log first 5 numeric releases for debugging
              console.log('Recent numeric releases:');
              numericReleases.slice(0, 5).forEach((rel, idx) => {
                console.log(`  ${idx + 1}. ${rel.tag_name} (${rel.created_at})`);
              });
              
            } catch (error) {
              core.setFailed(`Failed to get releases: ${error.message}`);
            }

      - name: Export release tag to env
        run: |
          echo "UPSTREAM_RELEASE_TAG=${{ steps.latest-release.outputs.tag }}" >> $GITHUB_ENV

      - name: Check for updates (latest release)
        id: check-updates
        run: |
          echo "Latest upstream release: $UPSTREAM_RELEASE_TAG"
          if [ -f LAST_UPSTREAM_RELEASE ]; then
            PREV_TAG=$(cat LAST_UPSTREAM_RELEASE)
          else
            PREV_TAG=""
          fi
          if [ "$PREV_TAG" = "$UPSTREAM_RELEASE_TAG" ] && [ "${{ github.event.inputs.force_sync }}" != "true" ]; then
            echo "updates=false" >> $GITHUB_OUTPUT
            echo "Already at latest upstream release $UPSTREAM_RELEASE_TAG"
          else
            echo "updates=true" >> $GITHUB_OUTPUT
            echo "Will update from '$PREV_TAG' to '$UPSTREAM_RELEASE_TAG'"
          fi

      - name: Prepare workspace
        if: steps.check-updates.outputs.updates == 'true'
        run: |
          # 备份现有的SSO集成修改
          mkdir -p /tmp/backup
          cp -r dify/api/libs/oauth.py /tmp/backup/ 2>/dev/null || true
          cp -r dify/api/configs/feature/__init__.py /tmp/backup/ 2>/dev/null || true
          cp -r dify/api/controllers/console/auth/oauth.py /tmp/backup/ 2>/dev/null || true
          cp -r dify/docker/docker-compose.yaml /tmp/backup/ 2>/dev/null || true
          cp -r keycloak/ /tmp/backup/ 2>/dev/null || true

      - name: Download and extract latest release
        if: steps.check-updates.outputs.updates == 'true'
        run: |
          echo "Downloading Dify release ${{ env.UPSTREAM_RELEASE_TAG }}"
          
          # Create temporary directory for download
          mkdir -p /tmp/dify-download
          cd /tmp/dify-download
          
          # Download release tarball
          curl -L -o dify-release.tar.gz "${{ steps.latest-release.outputs.tarball_url }}"
          
          # Extract tarball
          tar -xzf dify-release.tar.gz --strip-components=1
          
          # Backup existing dify directory
          cd ${{ github.workspace }}
          if [ -d "dify" ]; then
            rm -rf dify.backup 2>/dev/null || true
            mv dify dify.backup
          fi
          
          # Move extracted files to dify directory
          mv /tmp/dify-download dify
          
          echo "UPSTREAM_SRC=dify" >> $GITHUB_ENV

      - name: Apply SSO integration patches
        if: steps.check-updates.outputs.updates == 'true'
        run: |
          # Apply SSO integration script
          ./scripts/apply-sso-integration.sh
          
          # Also apply Paraview SSO patch if it exists
          if [ -f "paraview-sso-integration.patch" ]; then
            echo "Applying Paraview SSO integration patch"
            cd dify
            git init
            git add .
            git commit -m "Initial commit from upstream ${{ env.UPSTREAM_RELEASE_TAG }}"
            git apply ../paraview-sso-integration.patch || echo "Paraview patch application failed, continuing..."
            cd ..
          fi

      - name: Setup Docker Buildx
        if: steps.check-updates.outputs.updates == 'true'
        uses: docker/setup-buildx-action@v3
        with:
          platforms: ${{ env.BUILD_PLATFORMS }}

      - name: Login to Container Registry
        if: steps.check-updates.outputs.updates == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push API image
        if: steps.check-updates.outputs.updates == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.UPSTREAM_SRC }}/api
          platforms: ${{ env.BUILD_PLATFORMS }}
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-api:${{ env.UPSTREAM_RELEASE_TAG }}
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-api:latest
          provenance: false
          cache-from: |
            type=gha
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-api:${{ env.UPSTREAM_RELEASE_TAG }}
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-api:latest
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-api:cache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: Build and push Web image
        if: steps.check-updates.outputs.updates == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.UPSTREAM_SRC }}/web
          platforms: ${{ env.BUILD_PLATFORMS }}
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-web:${{ env.UPSTREAM_RELEASE_TAG }}
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-web:latest
          provenance: false
          cache-from: |
            type=gha
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-web:${{ env.UPSTREAM_RELEASE_TAG }}
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-web:latest
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-web:cache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: Build and push Worker image
        if: steps.check-updates.outputs.updates == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.UPSTREAM_SRC }}/api
          platforms: ${{ env.BUILD_PLATFORMS }}
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-worker:${{ env.UPSTREAM_RELEASE_TAG }}
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-worker:latest
          provenance: false
          cache-from: |
            type=gha
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-worker:${{ env.UPSTREAM_RELEASE_TAG }}
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-worker:latest
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-worker:cache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            SERVICE_TYPE=worker

      - name: Commit and push changes
        if: steps.check-updates.outputs.updates == 'true'
        run: |
          # Record the upstream release tag
          echo "${{ env.UPSTREAM_RELEASE_TAG }}" > LAST_UPSTREAM_RELEASE
          
          git add .
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "🚀 Sync from upstream ${{ env.UPSTREAM_REPO }} ${{ env.UPSTREAM_RELEASE_TAG }}
            
            - ✅ Updated dify/ to release ${{ env.UPSTREAM_RELEASE_TAG }}
            - ✅ Applied Keycloak OAuth integration automatically
            - ✅ Updated docker-compose.yaml with SSO environment variables
            - ✅ Built and pushed Docker images with latest upstream changes
            
            🔗 Upstream release: ${{ env.UPSTREAM_RELEASE_TAG }}
            📦 Images: ghcr.io/${{ github.repository_owner }}/dify-{api,web,worker}:${{ env.UPSTREAM_RELEASE_TAG }}"
            git push origin main
          fi

      - name: Create Release
        if: steps.check-updates.outputs.updates == 'true'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ env.UPSTREAM_RELEASE_TAG }}
          release_name: Dify Enterprise SSO - ${{ env.UPSTREAM_RELEASE_TAG }}
          body: |
            ## 🚀 Dify Enterprise SSO Release
            
            This release includes:
            - Latest Dify updates from upstream repository
            - Keycloak OAuth integration patch applied
            - Updated docker-compose.yaml with Keycloak environment variables
            - Fresh Docker images built from latest upstream code
            
            ### 🔗 Docker Images
            
            - **API**: `${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-api:latest`
            - **Web**: `${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-web:latest`
            - **Worker**: `${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-worker:latest`
            
            ### 📋 Changes
            
            - Synced from upstream: ${{ env.UPSTREAM_REPO }}@${{ env.UPSTREAM_BRANCH }}
            - Upstream commit: $(git rev-parse upstream/${{ env.UPSTREAM_BRANCH }})
            - Keycloak OAuth integration maintained
            - Environment variables updated
            
            ### 🚀 Quick Start
            
            ```bash
            # Pull the latest images
            docker pull ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-api:latest
            docker pull ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-web:latest
            docker pull ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-worker:latest
            ```
            
            ### 🔧 Multi-Platform Support
            
            Images are built for:
            - linux/amd64
            - linux/arm64
            
            ### 📦 Docker Compose
            
            ```yaml
            version: '3.8'
            services:
              api:
                image: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-api:latest
                environment:
                  - KEYCLOAK_CLIENT_ID=${KEYCLOAK_CLIENT_ID}
                  - KEYCLOAK_CLIENT_SECRET=${KEYCLOAK_CLIENT_SECRET}
                  - KEYCLOAK_ISSUER_URL=${KEYCLOAK_ISSUER_URL}
                  - ENABLE_SOCIAL_OAUTH_LOGIN=true
              
              web:
                image: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-web:latest
              
              worker:
                image: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-worker:latest
            ```
          draft: false
          prerelease: false

      - name: Update README with latest info
        if: steps.check-updates.outputs.updates == 'true'
        run: |
          # 更新README中的版本信息
          if grep -q "Last Updated:" README.md; then
            sed -i "s/Last Updated:.*/Last Updated: $(date +'%Y-%m-%d %H:%M UTC')/" README.md
          else
            echo "" >> README.md
            echo "## 📅 Version Information" >> README.md
            echo "" >> README.md
            echo "**Last Updated**: $(date +'%Y-%m-%d %H:%M UTC')" >> README.md
          fi
          
          if grep -q "Upstream Version:" README.md; then
            sed -i "s/Upstream Version:.*/Upstream Version: $(git rev-parse upstream\/${{ env.UPSTREAM_BRANCH }})/" README.md
          else
            echo "**Upstream Version**: $(git rev-parse upstream/${{ env.UPSTREAM_BRANCH }})" >> README.md
          fi
          
          git add README.md
          if git diff --staged --quiet; then
            echo "No README changes to commit"
          else
            git commit -m "Update README with latest sync information"
            git push origin main
          fi

      - name: Comment on PR if exists
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## 🔄 Dify Sync Status
            
              **Status**: ${{ steps.check-updates.outputs.updates == 'true' && '✅ Updated from upstream' || '✅ Already up to date' }}
              
              **Last Check**: $(date -u +'%Y-%m-%d %H:%M UTC')
              
              **Upstream Repository**: ${{ env.UPSTREAM_REPO }}
              **Upstream Branch**: ${{ env.UPSTREAM_BRANCH }}
              
              ${{ steps.check-updates.outputs.updates == 'true' && '**Changes Applied**:\n- ✅ Keycloak OAuth patch applied\n- ✅ Docker images built and pushed\n- ✅ docker-compose.yaml updated\n- ✅ Release created' || '**No Updates**: Repository is already synchronized with upstream' }}`
            })

      - name: Summary
        run: |
          echo "## 🎯 Sync Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Repository**: ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "**Upstream**: ${{ env.UPSTREAM_REPO }}@${{ env.UPSTREAM_BRANCH }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status**: ${{ steps.check-updates.outputs.updates == 'true' && '🔄 Updated' || '✅ Up to date' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check-updates.outputs.updates }}" = "true" ]; then
            echo "### 📦 Docker Images Built" >> $GITHUB_STEP_SUMMARY
            echo "- **API**: \`${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-api:latest\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Web**: \`${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-web:latest\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Worker**: \`${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-worker:latest\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### 🔧 Changes Applied" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Keycloak OAuth integration patch" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Environment variables updated" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Docker images rebuilt" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Release created" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### 🌐 Multi-Platform Support" >> $GITHUB_STEP_SUMMARY
            echo "Images built for: \`${{ env.DOCKER_PLATFORMS }}\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ℹ️ No Updates Required" >> $GITHUB_STEP_SUMMARY
            echo "Repository is already synchronized with upstream." >> $GITHUB_STEP_SUMMARY
          fi
